// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SwiftLayout
import Swift
import SwiftUI
import UIKit
import _Concurrency
@_hasMissingDesignatedInitializers final public class Activation : Swift.Hashable {
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
extension SwiftLayout.Activation {
  final public func deactive()
  final public func viewForIdentifier(_ identifier: Swift.String) -> UIKit.UIView?
  final public func store<C>(_ store: inout C) where C : Swift.RangeReplaceableCollection, C.Element == SwiftLayout.Activation
  final public func store(_ store: inout Swift.Set<SwiftLayout.Activation>)
}
extension SwiftLayout.Activation {
  public static func == (lhs: SwiftLayout.Activation, rhs: SwiftLayout.Activation) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers final public class Anchors {
  convenience public init(_ attributes: UIKit.NSLayoutConstraint.Attribute...)
  convenience public init(_ attributes: [UIKit.NSLayoutConstraint.Attribute])
  final public func equalTo(constant: CoreGraphics.CGFloat) -> Self
  final public func greaterThanOrEqualTo(constant: CoreGraphics.CGFloat = .zero) -> Self
  final public func lessThanOrEqualTo(constant: CoreGraphics.CGFloat = .zero) -> Self
  final public func equalTo<I>(_ toItem: I) -> Self where I : SwiftLayout.ConstraintableItem
  final public func greaterThanOrEqualTo<I>(_ toItem: I) -> Self where I : SwiftLayout.ConstraintableItem
  final public func lessThanOrEqualTo<I>(_ toItem: I) -> Self where I : SwiftLayout.ConstraintableItem
  final public func equalTo<I>(_ toItem: I, attribute: UIKit.NSLayoutConstraint.Attribute) -> Self where I : SwiftLayout.ConstraintableItem
  final public func greaterThanOrEqualTo<I>(_ toItem: I, attribute: UIKit.NSLayoutConstraint.Attribute) -> Self where I : SwiftLayout.ConstraintableItem
  final public func lessThanOrEqualTo<I>(_ toItem: I, attribute: UIKit.NSLayoutConstraint.Attribute) -> Self where I : SwiftLayout.ConstraintableItem
  final public func equalTo<I>(_ toItem: I, constant: CoreGraphics.CGFloat) -> Self where I : SwiftLayout.ConstraintableItem
  final public func greaterThanOrEqualTo<I>(_ toItem: I, constant: CoreGraphics.CGFloat) -> Self where I : SwiftLayout.ConstraintableItem
  final public func lessThanOrEqualTo<I>(_ toItem: I, constant: CoreGraphics.CGFloat) -> Self where I : SwiftLayout.ConstraintableItem
  final public func equalTo<I>(_ toItem: I, attribute: UIKit.NSLayoutConstraint.Attribute, constant: CoreGraphics.CGFloat) -> Self where I : SwiftLayout.ConstraintableItem
  final public func greaterThanOrEqualTo<I>(_ toItem: I, attribute: UIKit.NSLayoutConstraint.Attribute, constant: CoreGraphics.CGFloat) -> Self where I : SwiftLayout.ConstraintableItem
  final public func lessThanOrEqualTo<I>(_ toItem: I, attribute: UIKit.NSLayoutConstraint.Attribute, constant: CoreGraphics.CGFloat) -> Self where I : SwiftLayout.ConstraintableItem
  final public func setConstant(_ constant: CoreGraphics.CGFloat) -> Self
  final public func setMultiplier(_ multiplier: CoreGraphics.CGFloat) -> Self
  final public func equalTo(_ layoutAnchor: UIKit.NSLayoutXAxisAnchor) -> Self
  final public func equalTo(_ layoutAnchor: UIKit.NSLayoutYAxisAnchor) -> Self
  final public func equalTo(_ layoutAnchor: UIKit.NSLayoutDimension) -> Self
  final public func greaterThanOrEqualTo(_ layoutAnchor: UIKit.NSLayoutXAxisAnchor) -> Self
  final public func greaterThanOrEqualTo(_ layoutAnchor: UIKit.NSLayoutYAxisAnchor) -> Self
  final public func greaterThanOrEqualTo(_ layoutAnchor: UIKit.NSLayoutDimension) -> Self
  final public func lessThanOrEqualTo(_ layoutAnchor: UIKit.NSLayoutXAxisAnchor) -> Self
  final public func lessThanOrEqualTo(_ layoutAnchor: UIKit.NSLayoutYAxisAnchor) -> Self
  final public func lessThanOrEqualTo(_ layoutAnchor: UIKit.NSLayoutDimension) -> Self
  public static func horizontal<I>(_ item: I, offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors where I : SwiftLayout.ConstraintableItem
  public static func vertical<I>(_ item: I, offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors where I : SwiftLayout.ConstraintableItem
  public static func horizontal(offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors
  public static func vertical(offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors
  public static func allSides<I>(_ item: I, offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors where I : SwiftLayout.ConstraintableItem
  public static func allSides(offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors
  public static func cap<I>(_ item: I, offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors where I : SwiftLayout.ConstraintableItem
  public static func shoe<I>(_ item: I, offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors where I : SwiftLayout.ConstraintableItem
  public static func cap(offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors
  public static func shoe(offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors
  public static func size<I>(_ toItem: I, offset: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors where I : SwiftLayout.ConstraintableItem
  public static func size(length: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors
  public static func size<I>(_ toItem: I, offset: CoreGraphics.CGSize = .zero) -> SwiftLayout.Anchors where I : SwiftLayout.ConstraintableItem
  public static func size(_ size: CoreGraphics.CGSize = .zero) -> SwiftLayout.Anchors
  public static func center(offsetX: CoreGraphics.CGFloat = .zero, offsetY: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors
  public static func center<I>(_ toItem: I, offsetX: CoreGraphics.CGFloat = .zero, offsetY: CoreGraphics.CGFloat = .zero) -> SwiftLayout.Anchors where I : SwiftLayout.ConstraintableItem
  @objc deinit
}
public protocol ConstraintableItem {
}
extension UIKit.UIView : SwiftLayout.ConstraintableItem {
}
extension UIKit.UILayoutGuide : SwiftLayout.ConstraintableItem {
}
extension Swift.String : SwiftLayout.ConstraintableItem {
}
@_functionBuilder public struct AnchorsBuilder {
  public static func buildBlock(_ components: SwiftLayout.Anchors...) -> SwiftLayout.Anchors
  public static func buildEither(first component: SwiftLayout.Anchors) -> SwiftLayout.Anchors
  public static func buildEither(second component: SwiftLayout.Anchors) -> SwiftLayout.Anchors
  public static func buildArray(_ components: [SwiftLayout.Anchors]) -> SwiftLayout.Anchors
  public static func buildOptional(_ component: SwiftLayout.Anchors?) -> SwiftLayout.Anchors
  public static func buildExpression(_ expression: SwiftLayout.Anchors?) -> SwiftLayout.Anchors
}
@_functionBuilder public struct LayoutBuilder {
  public static func buildExpression<L>(_ layout: L) -> L where L : SwiftLayout.Layout
  public static func buildExpression<L>(_ layout: L?) -> SwiftLayout.OptionalLayout<L> where L : SwiftLayout.Layout
  public static func buildExpression<V>(_ uiView: V) -> SwiftLayout.ViewLayout<V> where V : UIKit.UIView
  public static func buildExpression<V>(_ uiView: V?) -> SwiftLayout.OptionalLayout<SwiftLayout.ViewLayout<V>> where V : UIKit.UIView
}
extension SwiftLayout.LayoutBuilder {
  public static func buildBlock<L>(_ layout: L) -> L
  public static func buildBlock<L, L1>(_ l: L, _ l1: L1) -> SwiftLayout.TupleLayout<(L, L1)>
  public static func buildBlock<L, L1, L2>(_ l: L, _ l1: L1, _ l2: L2) -> SwiftLayout.TupleLayout<(L, L1, L2)>
  public static func buildBlock<L, L1, L2, L3>(_ l: L, _ l1: L1, _ l2: L2, _ l3: L3) -> SwiftLayout.TupleLayout<(L, L1, L2, L3)>
  public static func buildBlock<L, L1, L2, L3, L4>(_ l: L, _ l1: L1, _ l2: L2, _ l3: L3, _ l4: L4) -> SwiftLayout.TupleLayout<(L, L1, L2, L3, L4)>
  public static func buildBlock<L, L1, L2, L3, L4, L5>(_ l: L, _ l1: L1, _ l2: L2, _ l3: L3, _ l4: L4, _ l5: L5) -> SwiftLayout.TupleLayout<(L, L1, L2, L3, L4, L5)>
  public static func buildBlock<L, L1, L2, L3, L4, L5, L6>(_ l: L, _ l1: L1, _ l2: L2, _ l3: L3, _ l4: L4, _ l5: L5, _ l6: L6) -> SwiftLayout.TupleLayout<(L, L1, L2, L3, L4, L5, L6)>
  public static func buildArray<L>(_ components: [L]) -> SwiftLayout.ArrayLayout<L> where L : SwiftLayout.Layout
  public static func buildOptional<L>(_ component: L?) -> SwiftLayout.OptionalLayout<L> where L : SwiftLayout.Layout
  public static func buildIf<L>(_ component: L?) -> SwiftLayout.OptionalLayout<L> where L : SwiftLayout.Layout
  public static func buildEither<True, False>(first component: True) -> SwiftLayout.ConditionalLayout<True, False> where True : SwiftLayout.Layout, False : SwiftLayout.Layout
  public static func buildEither<True, False>(second component: False) -> SwiftLayout.ConditionalLayout<True, False> where True : SwiftLayout.Layout, False : SwiftLayout.Layout
  public static func buildLimitedAvailability<L>(_ component: L) -> SwiftLayout.AnyLayout where L : SwiftLayout.Layout
}
public protocol Layout : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  var view: UIKit.UIView? { get }
  var anchors: SwiftLayout.Anchors { get }
  var sublayouts: [SwiftLayout.Layout] { get }
}
extension SwiftLayout.Layout {
  public var view: UIKit.UIView? {
    get
  }
  public var anchors: SwiftLayout.Anchors {
    get
  }
}
extension SwiftLayout.Layout {
  public func active(layoutIfNeededForcefully: Swift.Bool = false) -> SwiftLayout.Activation
  public func update(fromActivation activation: SwiftLayout.Activation, layoutIfNeededForcefully: Swift.Bool = false) -> SwiftLayout.Activation
  public func finalActive(layoutIfNeededForcefully: Swift.Bool = false)
  public var anyLayout: SwiftLayout.AnyLayout {
    get
  }
  public func updateIdentifiers(rootObject: Swift.AnyObject) -> some SwiftLayout.Layout
  
}
extension SwiftLayout.Layout {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var debugDetailDescription: Swift.String {
    get
  }
}
public struct AnyLayout : SwiftLayout.Layout {
  public var sublayouts: [SwiftLayout.Layout] {
    get
  }
}
public struct ArrayLayout<L> : SwiftLayout.Layout where L : SwiftLayout.Layout {
  public var sublayouts: [SwiftLayout.Layout] {
    get
  }
}
public struct ConditionalLayout<True, False> : SwiftLayout.Layout where True : SwiftLayout.Layout, False : SwiftLayout.Layout {
  public var sublayouts: [SwiftLayout.Layout] {
    get
  }
}
public struct GroupLayout<L> : SwiftLayout.Layout where L : SwiftLayout.Layout {
  public init(@SwiftLayout.LayoutBuilder _ handler: () -> L)
  public var sublayouts: [SwiftLayout.Layout] {
    get
  }
}
public struct OptionalLayout<L> : SwiftLayout.Layout where L : SwiftLayout.Layout {
  public var sublayouts: [SwiftLayout.Layout] {
    get
  }
}
public struct TupleLayout<L> : SwiftLayout.Layout {
  public var sublayouts: [SwiftLayout.Layout] {
    get
  }
}
public struct ViewLayout<V> : SwiftLayout.Layout where V : UIKit.UIView {
  public var sublayouts: [SwiftLayout.Layout] {
    get
  }
  public var anchors: SwiftLayout.Anchors {
    get
  }
  public var view: UIKit.UIView? {
    get
  }
}
extension SwiftLayout.ViewLayout {
  public func anchors(@SwiftLayout.AnchorsBuilder _ build: () -> SwiftLayout.Anchors) -> SwiftLayout.ViewLayout<V>
  public func sublayout<L>(@SwiftLayout.LayoutBuilder _ build: () -> L) -> SwiftLayout.ViewLayout<V> where L : SwiftLayout.Layout
  public func identifying(_ accessibilityIdentifier: Swift.String) -> SwiftLayout.ViewLayout<V>
}
extension Swift.Collection where Self.Element : SwiftLayout.Activation {
  public func viewForIdentifier(_ identifier: Swift.String) -> UIKit.UIView?
}
public protocol _UIViewExtension {
}
extension UIKit.UIView : SwiftLayout._UIViewExtension {
}
extension SwiftLayout._UIViewExtension where Self : UIKit.UIView {
  public func callAsFunction<L>(@SwiftLayout.LayoutBuilder _ build: () -> L) -> SwiftLayout.ViewLayout<Self> where L : SwiftLayout.Layout
  public func anchors(@SwiftLayout.AnchorsBuilder _ build: () -> SwiftLayout.Anchors) -> SwiftLayout.ViewLayout<Self>
  public func sublayout<L>(@SwiftLayout.LayoutBuilder _ build: () -> L) -> SwiftLayout.ViewLayout<Self> where L : SwiftLayout.Layout
  public func config(_ config: (Self) -> Swift.Void) -> Self
  public func identifying(_ accessibilityIdentifier: Swift.String) -> Self
  @discardableResult
  public func updateIdentifiers(rootObject: Swift.AnyObject? = nil) -> Self
}
extension UIKit.NSLayoutConstraint {
  @_Concurrency.MainActor(unsafe) public var shortDescription: Swift.String {
    get
  }
}
extension UIKit.NSLayoutConstraint.Attribute : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension UIKit.NSLayoutConstraint.Attribute : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension UIKit.NSLayoutConstraint.Relation : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public protocol LayoutableViewRepresentable : SwiftLayout.Layoutable, SwiftUI.UIViewRepresentable {
}
public protocol LayoutableViewControllerRepresentable : SwiftLayout.Layoutable, SwiftUI.UIViewControllerRepresentable {
}
extension SwiftLayout.LayoutableViewRepresentable where Self : UIKit.UIView {
  public func makeUIView(context: SwiftUI.UIViewRepresentableContext<Self>) -> Self
  public func updateUIView(_ view: Self, context: SwiftUI.UIViewRepresentableContext<Self>)
}
extension SwiftLayout.LayoutableViewControllerRepresentable where Self : UIKit.UIViewController {
  public func makeUIViewController(context: SwiftUI.UIViewControllerRepresentableContext<Self>) -> Self
  public func updateUIViewController(_ viewController: Self, context: SwiftUI.UIViewControllerRepresentableContext<Self>)
}
public protocol Layoutable : AnyObject {
  associatedtype LayoutBody : SwiftLayout.Layout
  var activation: SwiftLayout.Activation? { get set }
  @SwiftLayout.LayoutBuilder var layout: Self.LayoutBody { get }
  @available(*, deprecated, renamed: "self.sl.layout()", message: "updateLayout of Layoutable moved to sl wrapper type")
  func updateLayout()
}
extension SwiftLayout.Layoutable {
  @available(*, deprecated, renamed: "self.sl.layout()", message: "updateLayout of Layoutable moved to sl wrapper type")
  public func updateLayout()
  public var sl: SwiftLayout.LayoutableMethodWrapper<Self> {
    get
  }
}
@propertyWrapper final public class LayoutProperty<Value> {
  public init(wrappedValue: Value)
  public static subscript<Instance>(_enclosingInstance instance: Instance, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<Instance, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<Instance, SwiftLayout.LayoutProperty<Value>>) -> Value where Instance : SwiftLayout.Layoutable {
    get
    set
  }
  @available(*, unavailable, message: "This property wrapper can only be applied to Layoutable")
  final public var wrappedValue: Value {
    get
    set
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class LayoutableMethodWrapper<L> where L : SwiftLayout.Layoutable {
  final public func updateLayout(layoutIfNeededForcefully: Swift.Bool = false)
  @objc deinit
}
public struct SwiftLayoutPrinter : Swift.CustomStringConvertible {
  public struct PrintOptions : Swift.OptionSet {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public static let withSystemConstraints: SwiftLayout.SwiftLayoutPrinter.PrintOptions
    public static let onlyIdentifier: SwiftLayout.SwiftLayoutPrinter.PrintOptions
    public static let withViewConfig: SwiftLayout.SwiftLayoutPrinter.PrintOptions
    public typealias ArrayLiteralElement = SwiftLayout.SwiftLayoutPrinter.PrintOptions
    public typealias Element = SwiftLayout.SwiftLayoutPrinter.PrintOptions
    public typealias RawValue = Swift.Int
  }
  public init(_ view: UIKit.UIView, tags: [UIKit.UIView : Swift.String] = [:])
  public var description: Swift.String {
    get
  }
  @available(*, deprecated, message: "use PrintOptions")
  public func print(_ updater: SwiftLayout.IdentifierUpdater? = nil, systemConstraintsHidden: Swift.Bool = true, printOnlyIdentifier: Swift.Bool = false) -> Swift.String
  public func print(_ updater: SwiftLayout.IdentifierUpdater? = nil, options: SwiftLayout.SwiftLayoutPrinter.PrintOptions = []) -> Swift.String
}
@_hasMissingDesignatedInitializers final public class IdentifierUpdater {
  public static var nameOnly: SwiftLayout.IdentifierUpdater {
    get
  }
  public static var withTypeOfView: SwiftLayout.IdentifierUpdater {
    get
  }
  public static var referenceAndName: SwiftLayout.IdentifierUpdater {
    get
  }
  public static var referenceAndNameWithTypeOfView: SwiftLayout.IdentifierUpdater {
    get
  }
  final public func update(_ target: Any, prefix: Swift.String = "", fixedTags: Swift.Set<Swift.String> = [])
  @objc deinit
}
